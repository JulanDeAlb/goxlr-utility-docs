"use strict";(self.webpackChunkgoxlr_utiltiy_docs=self.webpackChunkgoxlr_utiltiy_docs||[]).push([[931],{4137:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),u=r,h=c["".concat(l,".").concat(u)]||c[u]||m[u]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9677:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(4137));const i={id:"messaging",title:"Messaging",sidebar_position:5},o="Messaging",s={unversionedId:"development/api/messaging",id:"development/api/messaging",title:"Messaging",description:"While not formally documented (yet!),",source:"@site/docs/development/api/messaging.md",sourceDirName:"development/api",slug:"/development/api/messaging",permalink:"/goxlr-utility-docs/docs/development/api/messaging",draft:!1,editUrl:"https://goxlr-on-linux.github.io/goxlr-utility-docs/docs/development/api/messaging.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{id:"messaging",title:"Messaging",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Websocket Request",permalink:"/goxlr-utility-docs/docs/development/api/websocket"},next:{title:"More Examples...",permalink:"/goxlr-utility-docs/docs/development/api/more-examples-etc"}},l={},p=[{value:"Sending",id:"sending",level:2},{value:"Receiving",id:"receiving",level:2}],d={toc:p},c="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"messaging"},"Messaging"),(0,r.kt)("p",null,"While not formally documented (yet!),\ndetermining the JSON messages to send across to the GoXLR is relatively straight forward.\nAll of the commands and responses are defined in the ",(0,r.kt)("inlineCode",{parentName:"p"},"ipc")," crates ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/GoXLR-on-Linux/goxlr-utility/blob/main/ipc/src/lib.rs"},"lib.rs"),"\nfile, DaemonRequest are the requests, and ",(0,r.kt)("inlineCode",{parentName:"p"},"DaemonResponse")," are the possible responses."),(0,r.kt)("h2",{id:"sending"},"Sending"),(0,r.kt)("p",null,"All requests should be derived from the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/GoXLR-on-Linux/goxlr-utility/blob/f9d2635e8692e6b8fb008155dc08c5fafd8cd353/ipc/src/lib.rs#L21"},"DaemonRequest"),"\nenum, if you send a request that's not listed there, or is of an incorrect format,\nan error will be returned. Serialization of the enums is straight forward,\nthe constant is converted to a String, and the parameters are represented either by themselves,\nor as an Array if there's more than one. If there ARE parameters,\nthe command needs to be wrapped in a JSON object ",(0,r.kt)("inlineCode",{parentName:"p"},"{}")," so the ",(0,r.kt)("inlineCode",{parentName:"p"},"DaemonRequest::GetStatus")," constant is represented in JSON as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'"GetStatus"\n')),(0,r.kt)("p",null,"With this information, we can infer the behavior of the ",(0,r.kt)("inlineCode",{parentName:"p"},"DaemonRequest::OpenPath")," command,\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/GoXLR-on-Linux/goxlr-utility/blob/f9d2635e8692e6b8fb008155dc08c5fafd8cd353/ipc/src/lib.rs#L49"},"PathTypes")," is an enum, and we know the constants are just represented as Strings in the JSON,\nand there's only one parameter, so an array isn't needed, but it needs to be wrapped in an object,\nso to open the profiles directory, the JSON would be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{ "OpenPath": "Profiles" } \n')),(0,r.kt)("p",null,"And ",(0,r.kt)("inlineCode",{parentName:"p"},"DaemonRequest::Command")," has two parameters, which need to be represented as an array, so we end up with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{ "Command": [String, GoXLRCommand] }\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," in this case is a device serial number (they're included in the ",(0,r.kt)("inlineCode",{parentName:"p"},"GetStatus")," response)...\nAs for the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/GoXLR-on-Linux/goxlr-utility/blob/f9d2635e8692e6b8fb008155dc08c5fafd8cd353/ipc/src/lib.rs#L84C10-L84C23"},"GoXLRCommand"),",\nthis is another enum further down the same file, listing all of the device commands that can be sent.\nThese commands all serialize out the same way as the top level elements.\nIt should be noted, that the commands include a lot of types, these can be found in the ",(0,r.kt)("inlineCode",{parentName:"p"},"types")," crates ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/GoXLR-on-Linux/goxlr-utility/blob/main/ipc/src/lib.rs"},"lib.rs"),"\nfile. They're all enums, so their values get sent as Strings."),(0,r.kt)("p",null,"So to set a Fader, we look to the ",(0,r.kt)("inlineCode",{parentName:"p"},"GoXLRCommand::SetFader")," constant,\nit requires a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/GoXLR-on-Linux/goxlr-utility/blob/f9d2635e8692e6b8fb008155dc08c5fafd8cd353/types/src/lib.rs#L55"},"FaderName"),"\nand a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/GoXLR-on-Linux/goxlr-utility/blob/f9d2635e8692e6b8fb008155dc08c5fafd8cd353/types/src/lib.rs#L14"},"ChannelName"),"\n(both defined in the types crate), so we'll change Fader ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," to the channel ",(0,r.kt)("inlineCode",{parentName:"p"},"Mic"),", remembering to start at the ",(0,r.kt)("inlineCode",{parentName:"p"},"DaemonRequest")," level, we end up with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{ "Command": [Serial, { "SetFader": ["A", "Mic"] } ] }\n')),(0,r.kt)("h2",{id:"receiving"},"Receiving"),(0,r.kt)("p",null,"Serialization of responses tends to behave in exactly the same way as serializing requests,\nexcept they're based on the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/GoXLR-on-Linux/goxlr-utility/blob/f9d2635e8692e6b8fb008155dc08c5fafd8cd353/ipc/src/lib.rs#L29C10-L29C25"},"DaemonResponse"),"\nenum. when executing a GoXLRCommand, you'll get one of two responses, either ",(0,r.kt)("inlineCode",{parentName:"p"},"Ok")," as a string by itself, or an error:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{ "Error": "This is an Error!" }\n')),(0,r.kt)("p",null,"Obviously, errors can be sent for any Request."),(0,r.kt)("p",null,"There are two other types of responses, ",(0,r.kt)("inlineCode",{parentName:"p"},"DaemonStatus")," fetched by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"GetStatus")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Patch"),", discussed earlier in the websocket section."),(0,r.kt)("p",null,"Serialisation of these structs is pretty straight forward, although they're defined in the ",(0,r.kt)("inlineCode",{parentName:"p"},"ipc")," crates ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/GoXLR-on-Linux/goxlr-utility/blob/main/ipc/src/device.rs"},"device.rs"),"\nfile."),(0,r.kt)("p",null,"In the case of a struct, the values inside it are represented as ",(0,r.kt)("inlineCode",{parentName:"p"},"key: value")," pairs, so for example a ",(0,r.kt)("inlineCode",{parentName:"p"},"DaemonConfig"),"\ninside the DaemonStatus struct would be represented as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'/* "Status" is from DaemonResponse */\n"Status": {\n  "config": {\n    "daemon_version": "0.12.4",\n\n    /* Rust boolean is mapped directly to javascript boolean */\n    "autostart_enabled": true,\n    "show_tray_icon": true\n  },\n  ...\n}\n')),(0,r.kt)("p",null,"For anything that's an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option"),", there will be either a value, or ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", this generally applies to feature that aren't present on a Mini."),(0,r.kt)("p",null,"For Maps (",(0,r.kt)("inlineCode",{parentName:"p"},"EnumMap"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"HashMap"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"BTreeMap"),"), the first type is the key, and the second the value, for example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"mixers")," are defined in rust as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"  pub mixers: HashMap<String, MixerStatus>,\n")),(0,r.kt)("p",null,"And map to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'"mixers": {\n  "SERIAL_NUMBER": {\n    /* Into the MixerStatus object */\n    "hardware": {\n      ...\n    }\n  },\n  "SERIAL_NUMBER_2": {\n    ...\n  }\n}\n')),(0,r.kt)("p",null,"For the ",(0,r.kt)("inlineCode",{parentName:"p"},"EnumMap<A, B>")," type, all keys of type A are GUARANTEED to be present and set in the response,\nin ",(0,r.kt)("inlineCode",{parentName:"p"},"HashMaps")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"BTreeMaps")," that guarantee is not met (note, in future releases, some HashMaps may be converted to EnumMaps)."),(0,r.kt)("p",null,"And finally, for types defined as ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec"),", they will be presented as a simple Javascript array."))}m.isMDXComponent=!0}}]);